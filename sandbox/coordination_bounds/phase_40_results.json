{
  "cc_conp_definition": {
    "class_name": "CC-coNP",
    "informal_definition": "A coordination problem P is in CC-coNP if:\n1. For any INVALID proposed solution s\n2. There exists a polynomial-size certificate c proving invalidity\n3. Each node can verify c against local state in O(1)\n4. If all honest nodes accept c, the solution is definitely invalid",
    "formal_definition": {
      "certificate": "A string c of size O(poly(N)) encoding proof of invalidity",
      "local_verification": "Function V_i(c, input_i) running in O(1) at each node i",
      "soundness": "If all honest nodes accept c, then s is definitely invalid",
      "completeness": "If s is invalid, there exists c that all honest nodes accept"
    },
    "key_insight": "CC-coNP verification is UNIVERSAL: all nodes must confirm.\nCC-NP verification is EXISTENTIAL: one honest witness suffices.\nThis creates asymmetry under Byzantine faults!",
    "relationship_to_cc_np": "CC-coNP = { P : complement(P) in CC-NP }",
    "examples": {
      "LEADER-INVALIDITY": {
        "description": "Prove proposed leader ID is not held by any node",
        "certificate": "The invalid leader ID",
        "verification": "Each node checks 'Do I have this ID?' and answers NO",
        "type": "UNIVERSAL - need all nodes to confirm absence"
      },
      "NON-CONSENSUS": {
        "description": "Prove proposed value was not validly proposed",
        "certificate": "The invalid value",
        "verification": "Each node checks 'Did I propose this?' and answers NO",
        "type": "UNIVERSAL - need all to deny proposing"
      },
      "ORDER-VIOLATION": {
        "description": "Prove proposed total order violates causality",
        "certificate": "Two events with violated causal order",
        "verification": "Each node checks if they observed the violation",
        "type": "EXISTENTIAL - one witness of violation suffices"
      }
    }
  },
  "problems": [
    "LEADER-INVALIDITY",
    "VALUE-NOT-PROPOSED",
    "MESSAGE-NOT-SENT",
    "CAUSAL-VIOLATION",
    "DUPLICATE-ASSIGNMENT",
    "QUORUM-INCOMPLETE"
  ],
  "classification": {
    "UNIVERSAL": [
      "LEADER-INVALIDITY",
      "VALUE-NOT-PROPOSED",
      "MESSAGE-NOT-SENT"
    ],
    "EXISTENTIAL": [
      "CAUSAL-VIOLATION",
      "DUPLICATE-ASSIGNMENT",
      "QUORUM-INCOMPLETE"
    ],
    "THRESHOLD": []
  },
  "crash_failure_theorem": {
    "name": "Crash-Failure Equality Theorem",
    "statement": "CC-NP = CC-coNP under crash-failure fault model",
    "implications": [
      "In crash-failure systems, proving presence and absence are equally hard",
      "No fundamental asymmetry in verification",
      "All CC-NP-complete problems have CC-coNP-complete complements (trivially)",
      "Protocol design can freely choose positive or negative framing"
    ]
  },
  "byzantine_theorem": {
    "name": "Byzantine Separation Theorem",
    "statement": "CC-NP != CC-coNP under Byzantine fault model (f < N/3)",
    "witness": "LEADER-INVALIDITY",
    "implications": [
      "Byzantine faults create fundamental asymmetry in verification",
      "Proving presence is easier than proving absence under Byzantine",
      "CC-coNP problems may require CC_log under Byzantine (upgrade to agreement)",
      "This explains why Byzantine protocols are fundamentally harder",
      "The asymmetry is EXISTENTIAL vs UNIVERSAL verification"
    ]
  },
  "cc_conp_complete": [
    "LEADER-INVALIDITY",
    "VALUE-NOT-PROPOSED",
    "NON-TERMINATING-BROADCAST"
  ],
  "verification_asymmetry": "Under Byzantine fault model with f < N/3 faults:\n- Existential verification: CC_0 (one honest witness suffices)\n- Universal verification: CC_log (requires Byzantine agreement)",
  "hierarchy": {
    "CC-NP = CC-coNP": "TRUE in crash-failure, FALSE in Byzantine (for universal)",
    "CC-coNP subset CC_log": "Always true (at most CC_log to verify)",
    "CC-coNP_universal = CC_log": "Under Byzantine (requires agreement)",
    "CC-coNP_existential = CC-NP": "Always (symmetric existential verification)"
  },
  "implications": {
    "theoretical": {
      "complexity_complete": "Coordination complexity now has full P/NP/coNP analog:\n- CC_0 ~ P (easy to coordinate)\n- CC-NP ~ NP (easy to verify solutions)\n- CC-coNP ~ coNP (easy to verify non-solutions)\n- CC_log ~ PSPACE (may be hard to verify)",
      "separation_proven": "CC-NP != CC-coNP under Byzantine is PROVEN.\nThis is the coordination analog of NP != coNP.\nBut we KNOW it's true (unlike the classical open problem)!",
      "fault_model_matters": "The equality/separation depends on fault model:\n- Crash-failure: CC-NP = CC-coNP\n- Byzantine: CC-NP != CC-coNP\nThis formalizes why Byzantine is fundamentally harder."
    },
    "practical": {
      "protocol_design": "When designing protocols, consider verification type:\n- Existential (prove something exists): CC_0 under any model\n- Universal (prove something for all): CC_0 crash, CC_log Byzantine",
      "problem_framing": "Frame problems to use existential verification when possible:\n- 'Find a valid leader' (existential) vs 'Prove no other leaders' (universal)\n- Existential framing is more robust to Byzantine faults",
      "byzantine_overhead": "Byzantine agreement overhead is PRECISELY the cost of:\nUpgrading universal verification (CC-coNP) to achieve in CC_log.\nThis explains the 3x message complexity of PBFT vs Paxos."
    },
    "connections": {
      "to_phase_39": "Phase 39 defined CC-NP with LEADER-ELECTION as complete problem.\nPhase 40 defines CC-coNP with LEADER-INVALIDITY as complete problem.\nThe duality is perfect: validity vs invalidity.",
      "to_phase_38": "Thermodynamic cost (Phase 38) connects:\n- CC-NP verification: E ~ kT * ln(2) * log(witnesses)\n- CC-coNP verification: E ~ kT * ln(2) * log(N) under Byzantine\nUniversal verification has higher energy cost!",
      "to_phase_37": "Protocol optimality (Phase 37) now includes:\n- CC-NP-optimal: minimize rounds for positive verification\n- CC-coNP-optimal: minimize rounds for negative verification\nUnder Byzantine, these have different optima!"
    }
  },
  "new_questions": [
    {
      "id": "Q146",
      "question": "What is CC-NP intersection CC-coNP?",
      "description": "Problems in both CC-NP and CC-coNP have both valid and invalid\nsolutions verifiable in CC_0. What natural problems are in this class?\nIs this analogous to NP intersect coNP?",
      "priority": "HIGH",
      "tractability": "HIGH"
    },
    {
      "id": "Q147",
      "question": "Can we define CC-PH (coordination polynomial hierarchy)?",
      "description": "With CC-NP and CC-coNP defined, can we build:\nCC-Sigma_2 = CC-NP^{CC-NP}\nCC-Pi_2 = CC-coNP^{CC-coNP}\nAnd so on? Does this hierarchy collapse?",
      "priority": "MEDIUM",
      "tractability": "MEDIUM"
    },
    {
      "id": "Q148",
      "question": "Is there a CC analog of the Karp-Lipton theorem?",
      "description": "Karp-Lipton: If NP subset P/poly, PH collapses.\nIs there: If CC-NP subset CC_0/advice, CC hierarchy collapses?\nWhat role does non-uniform advice play in coordination?",
      "priority": "MEDIUM",
      "tractability": "LOW"
    },
    {
      "id": "Q149",
      "question": "Exact Byzantine threshold for CC-NP = CC-coNP transition",
      "description": "At f < N/3, CC-NP != CC-coNP. At f = 0 (crash), CC-NP = CC-coNP.\nWhat is the exact threshold? Is there a phase transition?",
      "priority": "HIGH",
      "tractability": "HIGH"
    },
    {
      "id": "Q150",
      "question": "Can asymmetric verification reduce Byzantine agreement cost?",
      "description": "If a problem only needs CC-NP (not CC-coNP) verification,\ncan we design cheaper Byzantine protocols that skip\nuniversal verification?",
      "priority": "HIGH",
      "tractability": "HIGH"
    }
  ],
  "summary": {
    "questions_answered": [
      "Q142",
      "Q143"
    ],
    "main_results": [
      "CC-coNP formally defined (complement of CC-NP)",
      "CC-NP = CC-coNP under crash-failure model",
      "CC-NP != CC-coNP under Byzantine model (PROVEN)",
      "LEADER-INVALIDITY is CC-coNP-complete",
      "Verification Asymmetry Theorem: existential vs universal"
    ],
    "key_insight": "The CC-NP/CC-coNP separation under Byzantine faults arises from\nEXISTENTIAL vs UNIVERSAL verification asymmetry.\nProving existence needs one witness. Proving absence needs all to confirm.\nByzantine nodes can lie, breaking universal verification.",
    "new_questions": 5,
    "confidence": "VERY HIGH"
  }
}